**Function(함수)
=>독립적으로 존재하지만 독립적으로 실행할 수 있는 모듈
=>실제 작업의 처리 단위
=>Function이 클래스 안에 작성되서 클래스나 인스턴스를 이용해서 호출되면 메소드
=>호출하는 대상(Receiver)이 있으면 메소드라고 하고 없으면 함수라고 합니다.
=>함수를 생성(선언)하고 호출(실행)하는 구조로 사용
=>함수의 원형: 함수의 모양(어떻게 호출하고 어떤 결과를 남겨주는지 확인)
함수이름(매개변수) -> 리턴타입 : UML이 이런식으로 표현
다른 언어에서는 리턴타입 함수이름(매개변수) 의 형태로 작성합니다.
자신이 만든 메소드는 자신이 호출하기 때문에 오른쪽의 패키지 나 프로젝트 창을 보면 모양이 보입니다.
SDK 나 Framework가 제공하는 함수나 메소드의 경우는 Document에서 원형을 찾아서 개발자가 직접 호출을 해야 합니다.
SDK를 학습할 때는 이 메소드가 재사용이 될 것 같으면 Document에서 원형을 찾아서 기록을 해두던가 외우는 것이 좋습니다.

=>함수나 메소드를 학습하는 순서
원형을 보고 호출하는 것을 학습
자신이 구현하고자 하는 기능의 메소드 원형을 만드는 것을 학습
메소드 안의 내용을 채우는 것을 학습

1.swift 에서 함수를 만드는 방법
func 함수이름(매개변수 나열) -> 리턴타입{
	함수의 내용
	리턴타입이 있으면 return 데이터
}
=>매개변수가 없으면 ( ) : 괄호는 없어도 생략할 수 없음
=>리턴타입이 없으면 Void 라고 적거나 -> 리턴타입 부분을 생략

2.swift에서 함수 호출
함수이름(매개변수이름:매개변수…)

3.클라이언트 프로그램 과 서버 프로그램에서의 매개변수 생성의 차이점
=>매개변수가 2개 이상인 경우 서버 프로그래머들은 이 부분을 DTO 클래스나 Map으로 묶어서 처리하는 것을 선호
=>클라이언트 프로그래머들은 나열하는 방식을 선호
swift 나 kotlin에서는 나열하는 방식을 선호하고 Spring 같은 서버 프레임워크에서는 DTO 형태로 묶는 것을 선호

//하나의 문자열을 받아서 출력하는 함수
func disp(message:String) -> Void{
    print(message)
}

//함수 호출
disp(message: "Swift는 UML과 유사한 형태로 코드를 작성")

4.함수를 선언하는 부분이 호출하는 부분보다 아래 있어도 됩니다.
=>함수, 구조체, 클래스, 프로토콜 과 같은 선언을 하는 부분은 호출하는 부분보다 아래 있어도 됩니다.
컴파일러는 해석을 할 때 선언 부분을 전부 찾아서 메모리에 할당을 하고(static) 그 이후 다시 처음부터 읽어가면서 수행하기 때문입니다.

5.매개변수(Argument)
=>함수나 메소드를 호출할 때 넘겨주는 데이터
=>매개변수는 함수 내에서만 사용할 수 있는 지역변수(Local Variable - 선언된 영역에서만 사용 가능한 변수)
=>함수 내부에서 부를 때는 Parameter 라고 합니다.
=>함수를 호출할 때 매개변수를 대입할 때 매개변수 이름과 함께 대입을 해야 합니다.
함수(매개변수이름:매개변수) 형태로 호출합니다.

1)매개변수 이름을 사용함으로써 발생하는 문제
=>매개변수이름을 이해하기 쉽도록 만들려고 이름을 길게 만들면 외부에서 대입할 때 불편 : 별명을 사용할 수 있도록 함
=>누구나 예측할 수 있는 매개변수의 이름을 사용하는 것은 자원의 낭비가 될 수 있음 
앞에 _를 붙여서 생략할 수 있도록 해 줌
=>이렇게 생략하는 것은 맨 앞에 하나만 해주는 것이 좋고 예측이 가능해야 합니다.
2개 이상 이름을 생략할 수 있도록 하면 순서의 문제가 발생할 수 있고 예측이 불가능하면 사용자는 구현된 내용을 살펴봐야 합니다.

//위의 함수를 별명을 이용해서 매개변수를 대입하도록 수정
//뒤의 이름은 친절한 설명인 경우가 많고
//앞의 이름은 약자인 경우가 많습니다.
/*
func disp(msg message:String) -> Void{
    print(message)
}

disp(msg: "매개변수에 별명 사용")
*/

//위의 함수를 매개변수이름을 생략하고 사용할 수 있도록 수정
//iOS SDK에서는 첫번째만 생략합니다.
func disp(_ message:String){
    print(message)
}

disp("매개변수 생략")

2)매개변수의 생략 - 기본값을 설정
=>매개변수를 생략할 수 있도록 할려면 반드시 매개변수의 자료형을 기재해야 합니다.
func 함수이름(매개변수이름 : 자료형 = 기본값…)
=>위의 매개변수는 생략하면 기본값이 설정됩니다.
=>생략은 뒤에서부터 해야 합니다.
=>앞의 매개변수를 생략하고 뒤의 매개변수를 대입하는 구조는 안됩니다.

3)varargs
=>매개변수의 개수를 가변으로 입력하는 구조
func 함수이름(매개변수이름 : 자료형 . . .)
=>내부적으로 처리할 때는 데이터를 묶어서 배열로 간주
=>java 나 kotilin에도 있는데 거의 사용하지 않음
=>이 방식이 데이터베이스 연동 프레임워크에서 PreparedStatement 구조를 만들 때 ?를 사용하는 경우 ?에 값 대입할 때 이용되는 경우 와 출력하는 함수에 이용합니다.

print(“Hello”)
print(“Hello”, “World”)
print(“Hello”, “World”, “Swift”)

4)Call by Value & Call by Reference
=>Call by Value: 매개변수의 자료형이 일반 데이터인 경우
값을 복사해서 대입하는 형태가 되서 호출하는 곳의 데이터를 함수가 변경할 수 없다.
자바에서 메소드에게 값을 넘겨주었으면 절대로 값이 변경되지 않는다.

=>Call by Reference: 매개변수의 자료형이 참조형인 경우
저장하고 있는 값이 참조라서 참조를 복사해서 대입하는 형태가 되서 호출하는 곳의 데이터를 함수가 변경할 수 있다.
자바에서 메소드에 참조를 넘겨주었으면 값이 변경될 수 도 있다.

=>프로그래밍에서는 Call by Value를 선호
넘겨준 데이터를 함수가 변경하게 되면 어떤 이유로 변경되었는지 확인해야 하기 때문
Call by Reference를 사용하는 경우는 메모리 절약을 하기 위해서 

5)복사
=>저장하고 있는 데이터를 그냥 대입
=>weak copy: 참조하고 있는 데이터를 복사 - 재귀적으로 복사하지는 않음
=>deep copy: 참조하고 있는 데이터를 복사 - 재귀적으로 복사합니다.


참조형 -> 일반값: weak copy 나 deep copy가 차이가 없음


참조형 -> 참조형 -> 일반값: weak copy 는 일반값을 복제하지 않고 두번째 있는 참조형의 데이터만 복제를 하고 deep copy 다시 한번 찾아가서 일반값을 복사
deep copy는 일반 값이 나올 때 까지 재귀적으로 찾아가서 값을 복사해주는 방식

6)swift에 참조복사
=>swift의 함수는 매개변수에 대입할 때 기본적으로 데이터를 복제해서 대입
=>참조를 대입하고자 하면 매개변수 앞에 inout을 추가해주면 됩니다.
=>함수를 호출할 때는 &를 붙여서 대입
=>예외적으로 클래스로부터 만들어진 인스턴스를 매개변수로 사용하는 경우에는 참조가 복사됩니다.

7)swift 에서는 함수가 일급객체
=>함수를 하나의 자료형으로 간주 : javascript 도 동일
=>함수를 하나의 변수에 대입할 수 있고 리턴할 수 있습니다.
=>자바스크립트 closure : 함수가 함수를 리턴해서 외부에서 함수 내부의 데이터를 조작할 수 있도록 하는 기능

//swift는 함수가 일급객체 - 하나의 자료형
//함수를 다른 변수에 대입하는 것이 가능
var display = disp
display("스위프트는 함수가 일급 객체")

=>변수에 함수를 직접 저장하는 경우는 드물고 함수를 다른 함수의 매개변수로 받을 수 있도록 하기 위해서 사용하는 경우가 많음
iOS Framework에서는 메소드의 매개변수로 함수를 대입받을 수 있습니다.

6.return
=>함수는 수행을 종료하고 호출한 곳으로 돌아가는데 이것을 return 이라고 합니다.
호출한 곳으로 돌아가는 것
=>함수는 return을 할 때 하나의 데이터를 가지고 돌아갈 수 있는데 이 데이터의 자료형을 return type 이라고 합니다.
함수를 호출한 곳에서는 이 return 되는 데이터를 확인해서 다음 작업을 수행할 수 있습니다.
=>return 할 때 여러 개의 데이터를 가지고 리턴을 해야 하면 Dictionary 나 DTO 클래스를 이용할 수 있고 swift에서는 구조체 와 튜플을 이용할 수 도 있습니다.
=>파이썬이나 스위프트를 공부하다가 함수가 여러 개의 데이터를 리턴해야 하면 튜플을 사용해야 한다라고 나오는 부분이 있으면 이 의미는 튜플로도 할 수 있다라는 의미입니다.

=>리턴할 데이터가 없으면 리턴 타입을 Void라고 하고 생략해도 되고 Void라고 써도 됩니다.
=>리턴되는 데이터가 있으면 그 데이터를 이용해서 다른 함수를 호출할 수 있습니다.
이것을 메소드 체이닝이라고 합니다.

//양수를 입력받아서 양수까지의 피보나치 수열을 리턴하는 함수
func fiboNoRecursion(su:UInt32) -> UInt32{
    if su == 1 || su == 2{
        return 1
    }
    //이전 첫번째 항의 값을 저장할 변수
    var x1:UInt32 = 1
    //이전 두번째 항의 값을 저장할 변수
    var x2:UInt32 = 1
    //피보나치 수열의 값을 저장할 변수
    var result:UInt32 = 1
    
    for _ in 3...su{
        result = x1 + x2
        x2 = x1
        x1 = result
    }
    return result
}
//리턴되는 데이터가 있는 함수는
//결과를 가지고 다음 작업을 수행할 수 있습니다.
print(fiboNoRecursion(su: 10) + 30)

1)Recursion(재귀함수)
=>함수가 자기 자신을 다시 리턴하는 함수
=>함수가 내부에서 다시 함수를 호출하는 구조라서 메모리 사용량이 많고 속도는 느림
=>소스 코드를 이해하기 쉽고 짧게 만들 수 있습니다.
=>합계, 팩토리얼, 피보나치 수열, 하노이의 탑, quick sort, 미로 찾기 등이 재귀함수를 이용해서 구현하는 대표적인 예 

//위의 함수를 재귀로 구현
func fiboRecursion(su:UInt32) -> UInt32{
    if su == 1 || su == 2{
        return 1
    }
    //피보나치 수열은 이전 2개의 항의 합
    return fiboRecursion(su: su-1) + fiboRecursion(su: su-2)
}

print(fiboRecursion(su: 10))

2)nested function
=>함수 안에 만들어진 함수
=>함수 안에서 함수를 만들어서 리턴해서 함수 외부에서 함수 내부의 값을 변경하기 위해서 생성하는 경우가 많습니다.
이 개념을 자바스크립트에서는 클로저라고 합니다.

//내부 함수 - 함수 안에 포함된 함수
//함수를 리턴
func outer() -> (() -> Void){
    //x는 지역변수 : 함수 외부에서는 변경이 불가능
    var x = 0
    //내부에 함수를 생성
    func inner() -> Void{
        x = x + 1
        print(x)
    }
    //함수를 리턴
    return inner
}

//외부 함수를 호출해서 함수를 저장
var f = outer()
//outer에 만들어진 inner를 호출
f()
f()

=>변수는 영역에 따라서 나눌 때 지역변수, 인스턴스 변수, 전역 변수로 나누는 경우가 있습니다.
서로 다른 영역에서 하나의 변수를 공유할려면 전역변수를 사용해야 합니다.
=>객체 지향에서는 전역변수 사용을 금기시 합니다.
전역변수는 모든 영역에서 수정이 가능하기 때문에 전역변수의 값을 확인할려면 프로그램 모든 부분을 읽어봐야 합니다.
프로그램을 이해하기 어렵게 만들어서 유지보수가 어렵게 됩니다.
=>함수 안에서 함수를 리턴하는 구조를 만들어서 함수 내부의 데이터를 수정할 수 있다면 전역변수를 사용하지 않아도 됩니다.
=>자바스크립트에서는 이 개념을 closure라고 하고 자바스크립트 기본 문법 책들에는 거의 이 내용이 없고 있는 경우에도 보통 가장 마지막 섹션에 포함되어 있습니다.
개념과 용도는 많이 중요합니다.
Web 프로그래밍 면접 볼 때 Front End에서 가장 어렵고 중요하게 생각하는 개념이 ajax 와 closure 입니다.

3)swift 의 closure
=>Java의 람다의 개념
=>이름없는 함수를 만드는 개념
=>이벤트 처리를 할 때 작업은 함수가 수행하기 때문에 swift에서는 이벤트 처리 핸들러가 객체가 아니고 함수입니다.
함수도 하나의 이름을 가지고 정의하는 것이라서 한 번 만들면 계속해서 존재하게 됩니다.
순간 만들었다가 필요가 없어지면 삭제할 수 있도록 해야 하는데 이렇게 할려면 이름이 없어야 합니다.
=>생성
{(매개변수 나열) -> 리턴타입 in
	함수의 내용
}
매개변수가 1개인 경우는 ()를 생략하는 것이 가능
매개변수가 없거나 2개 이상인 경우는 ()를 생략하면 안됩니다.

=>trailing closure
swift에서는 함수의 매개변수로 함수가 설정된 경우 매개변수가 가장 마지막이라면 ()안에서 대입하는 것이 아니고 () 바깥에 클로저를 만들어서 연결할 수 있습니다.
iOS SDK 의 샘플 코드들의 이벤트 처리가 이 trailing closure로 만들어진 경우가 많습니다.

=>@escaping
함수의 매개변수로 함수가 설정된 경우 함수 내부에서 매개변수로 대입된 함수를 다른 변수에 대입할 수 가 없는데 매개변수를 만들 때 @escaping을 사용하면 다른 변수에 대입하고 사용할 수 있습니다.


=>@autoclosure
일반 구문을 대입해도 클로저 구문으로 변경하고자 할 때 사용하는 어노테이션 

//배열 생성
var ar = [30, 10, 20]
//기본 정렬
//ar.sort()

/*
//2개의 크기를 비교해서 Bool 으로 리턴하는 함수
func myComp(n1:Int, n2:Int) -> Bool{
    return n1 > n2
}
//원하는 함수를 적용해서 정렬
ar.sort(by:myComp)
*/

/*
//closure를 이용해서 위와 동일한 작업
//closure는 이름없이 코드 만으로 함수를 생성
//Java에서 람다와 유사
ar.sort(by:{(n1:Int, n2:Int) -> Bool in
    return n1 > n2
})
*/

//trailing closure
//함수가 매개변수의 가장 마지막 요소로 설정된 경우에는
//closure를 () 뒤에 부착하는 것이 가능
//iOS SDK 는 이 방법을 많이 사용
ar.sort(){(n1:Int, n2:Int)->Bool in
    return n1 > n2}

//정렬된 데이터를 출력
print(ar)

4)함수에서 중요
=>함수를 호출하는 방법
=>iOS SDK에서는 closure - 작성 방법보다는 샘플 코드에서의 의미
함수가 매개변수인 경우 closure 형태로 도큐먼트에 설명되므로 closure를 보고 어떤 형태를 대입해야 하는지 잘 파악할 수 있어야 합니다.
=>이 구조를 파악할 수 있어야 call back 함수를 만들 수 있습니다.
Call back : 이벤트가 발생했을 때 호출되는 것

5)함수라는 개념이 있기는 하지만 iOS SDK에는 함수를 거의 제공하지 않습니다.

**객체 지향 
Class: 관련성있는 변수(저장)와 함수(기능)의 집합

Instance: Class를 기반으로 메모리 할당을 받은 객체

Encapsulation: 불필요한 부분은 숨기고 필요한 부분만 외부로 노출 - 접근지정자, 정보은닉
Inheritance: 상속 - 상위 클래스의 모든 것을 하위 클래스가 물려 받는 것, 재사용성을 증가
    Super(Base) Class: 상위 클래스
    Sub(Derived) Class: 하위 클래스
Polymorphism: 다형성 - 동일한 메시지에 대하여 다르게 반응하는 성질
                                      동일한 코드가 대입된 인스턴스에 따라서 다른 메소드를 호출하는 것

Abstract: 하위 클래스들에 동일한 요소가 있을 때 이를 위로 올리는 것

Interface(Protocol): 모양만 만들어두고 하위 클래스에서 구현(implementation, conform)하도록 한 것 - 템플릿 메소드 패턴, 메뉴판

Method Overloading: 하나의 클래스에 메소드 이름은 같고 매개변수의 개수나 자료형이 다른 메소드가 존재하는 것

Method Overriding: 상위 클래스의 메소드를 하위 클래스에서 다시 정의하는 것
=>swift에서는 상위 클래스의 메소드를 다시 정의하는 것을 오버라이딩이라고 하고 Protocol의 메소드를 다시 정의하는 것은 오버라이딩 이라고 하지 않음

**구조체(Struct)
=>공통된 목적을 달성하기 위해 모인 변수와 함수의 집합
=>사용자 정의 자료형 : 내부 요소를 개발자가 마음대로 구성할 수 있는 자료형
=>Swift에서는 Struct는 Value Type이고 Class는 Reference Type
=>Swift에서 제공하는 자료형들은 대부분 Struct 이고 iOS SDK에서 제공하는 자료형들은 대부분 Class
=>구조체나 클래스 안에 만들어진 변수들은 property 또는 attribute 나 field 라고 합니다.
함수는 method라고 합니다.
이 둘을 합쳐서 member 라고 하는 경우가 많습니다.
=>구조체 나 클래스는 하나의 자료형이기 때문에 대부분의 경우는 이 자료형을 기반으로 메모리를 할당받아서 사용 - 인스턴스

1.구조체 와 클래스의 공통점
=>프로퍼티와 메소드를 소유할 수 있음
=>서브스크립트 : 프로퍼티에 접근하기 위한 방법
=>초기화 블럭(생성자) :  init
=>확장(extension) 가능 : Kotlin 과 C#에 유사한 개념이 있음
=>프로토콜을 사용할 수 있음

2.구조체 와 클래스의 차이점
=>구조체는 상속이 안됨
=>구조체는 소멸자가 없음
=>구조체는 데이터를 대입할 때 자료형 검사를 안함
잘못된 데이터를 대입하면 예외가 발생
클래스는 잘못된 데이터를 대입하면 에러 표시
=>구조체는 값 형식이고 클래스는 참조 형식
구조체는 값들의 집합일 뿐이고 클래스는 인스턴스를 생성하고 그 인스턴스의 참조를 사용하는 개념
=>구조체는 참조 카운팅을 하지 않음
=>구조체는 생성자를 별도로 만들지 않아도 생성할 때 값을 대입해서 생성하는 것이 가능

3.구조체와 클래스 사용을 결정
=>데이터의 집합을 나타낼 때는 구조체 그 이외의 경우는 클래스
이전에 만들던 DTO는 구조체나 튜플을 이용

4.구조체 생성
struct 구조체이름{
	속성(변수)
	메소드(함수)
	생성자(init)
}

5.구조체를 이용하는 객체 생성
구조체이름(데이터 나열) 또는 구조체이름.init(데이터 나열)
=>init은 작성해도되고 안해도 됩니다.

구조체이름 변수 = 구조체이름(데이터 나열)  처럼 하는 것은 구조체 객체를 생성하고 이 객체를 재사용하기 위해서 변수에 참조를 저장하는 것입니다.

6.멤버 호출
변수.속성이름
변수.메소드(매개변수): 메소드를 호출하는 것입니다. 실행
변수.메소드 라고 하면 메소드의 참조를 의미하는 것입니다.

7.명명법
=>Camel 표기법을 권장
구조체나 클래스 이름은 대문자로 시작
속성이나 메소드명은 소문자로 시작
2개 단어 이상의 조합으로 만들어지는 경우에는 두번째 단어의 시작을 대문자로


//구조체(DTO 클래스 대용) 생성
//번호와 이름을 저장하는 구조체를 생성
struct Person{
    //프로퍼티를 선언 : nil을 저장할 수 있도록 ?와 함께 선언
    //Optional Type
    var num:Int?
    var name:String?
    
    //메소드 생성
    func disp() -> Void{
        print("번호는 \(num!) 이름은 \(name!)")
    }
    
    //생성자 - 매개변수가 없는 생성자(Default Constructor)
    //인스턴스 변수의 값을 특정 값으로 초기화하고자 할 때 생성
    init(){
        num = 1
        name = "noname"
    }
    //생성자 오버로딩: 하나의 클래스에 동일한 이름의 메소드가
    //2개 이상 존재
    //매개변수가 있는 생성자: 데이터를 주입받아서 인스턴스
    //변수를 초기화하기 위해서
    init(num:Int?, name:String?){
        self.num = num
        self.name = name
    }
}

//함수, 구조체나 클래스는 사용자 정의 자료형
//생성만 해서는 사용할 수 없고 메모리 할당 받아서 사용
//함수는 호출
//구조체나 클래스는 객체를 생성해서 사용

//구조체 객체 만들기
//swift에서는 생성자만 호출해도 되고 init 으로 직접 초기화
//메소드를 호출해도 됩니다.
var person1 = Person()
var person2 = Person(num: 1, name: "park")
var person3 = Person.init(num: 2, name: "척준경")
//멤버 호출
person1.disp()
//정수, 실수, Bool, 구조체, 열거형은
//대입을 하면 데이터를 복제해서 대입
//대입을 하면 다른 쪽의 변경이 원본에 영향이 없습니다.
var person4 = person1
//person4의 내용을 변경해도 person1은 영향을 받지 않습니다.
person4.num = 99
person4.disp()
person1.disp()


**class
=>동일한 목적을 위해 모인 프로퍼티와 메소드의 모임
=>사용자 정의 자료형
=>클래스가 생성하는 인스턴스는 참조형
다른 변수에 참조를 대입하면 데이터가 복사되는 것이 아니고 참조가 복사
1.클래스의 생성
=>구조체의 struct를 class로 변경

2.인스턴스 생성
생성자(매개변수 대입)
생성자.init(매개변수 대입)

3.Property
=>데이터를 저장하거나 읽기 위한 목적으로 구조체나 클래스 안에 선언한 변수나 상수
=>다른 말로는 field, attribute, 속성이라고도 합니다.
=>변수를 만들 때는 var 상수를 만들 때는 let을 사용
1)종류
=>저장 프로퍼티: 값을 저장할 목적으로 생성
저장 프로퍼티를 만들 때는 초기값을 바로 할당할 것이 아니라면 Optional Type으로 생성
대다수의 경우 ? 보다는 !를 이용해서 선언 - 강제로 Optional을 해제하지 않고 사용 가능
init 메소드에서 초기화할거라면 Optional 을 사용하지 않아도 됩니다.

=>연산 프로퍼티: 값을 계산해서 리턴할 목적으로 생성
var 프로퍼티이름 : 자료형{
	get{
		return 데이터
	}
	set(value){
		수행할 작업
	}
}
get은 필수이고 set은 선택
만들기는 get 과 set을 만들어서 접근자 메소드를 만들지만 사용은 변수처럼 합니다.
= 를 기준으로 오른쪽에 사용되면 set으로 간주하고 그 이외의 경우는 무조건 get

연산 프로퍼티를 만드는 경우는 국어점수, 수학점수, 영어점수를 저장하는 구조체나 클래스를 만들 때 합계를 자주 사용하는 경우 매번 국어점수, 수학점수, 영어점수를 더해서 구하는 것은 시간이 걸리게 됩니다.
이럴 때는 합계라는 프로퍼티를 만드는 데 합계 프로퍼티는 데이터를 저장하는 것이 목적이 아니고 계산을 해서 리턴하는 것이 목적이므로 이런 경우에 저장 프로퍼티를 만들면 효율적입니다.

관계형 데이터베이스에서 테이블을 만들 때 어떤 계산 작업을 자주 사용한다면 컬럼을 만들어두고 사용하는 것이 빠르게 사용할 수 있는 방법 중 하나 - 반정규화

2)lazy init(지연 생성)
=>프로퍼티를 만들 때 앞에 lazy를 추가하면 됩니다.
=>지연생성은 인스턴스가 생성될 때 만드는 것이 아니고 처음 프로퍼티를 사용할 때 만들어주는 개념
=>서버 프로그램 과 클라이언트 프로그램의 차이
서버 프로그램은 처음부터 전부 가지고 시작하는게 좋습니다.
서버 프로그램은 신뢰성이 우선

클라이언트 프로그램은 필요할 때 생성하는 것이 좋습니다.
클라이언트 프로그램은 가용성이 우선

=>클라이언트 프로그램을 만들 때 하나의 클래스로부터 여러 개의 인스턴스를 만들고 오랜 시간 동안 동작해야 하는 프로그램을 만들 때는 지연생성을 고려해야 합니다.
지연생성을 많이 사용하는 애플리케이션이 게임

class Rect{
    //저장 프로퍼티 : 변수
    var x = 0
    var y = 0
    var width = 0
    var height = 0
    
    //연산 프로퍼티
    //get을 하면 x, y 그리고 width 와 height를
    //가지고 계산해서 리턴
    
    //set을 하면 x, y 값을 수정
    var center:(Int, Int){
        get{
            return ((x+width)/2, (y+height)/2)
        }
        set(value){
            x = (value.0 - width/2)
            y = (value.1 - height/2)
        }
    }
}

//인스턴스 생성
var rect:Rect = Rect()
//저장 프로퍼티에 값을 대입
//스위프트(iOS SDK)에서는 프로퍼티에 값을 대입할 때
//변수를 직접 호출하는 구조로 사용합니다.
rect.x = 100
rect.y = 200
rect.width = 200
rect.height = 200

//연산 프로퍼티 호출 : 프로퍼티를 호출하면 get의 내용을 수행해서
//리턴합니다.
print(rect.center)

//연산 프로퍼티에 값을 대입
//특별한 경우가 아니면 연산 프로퍼티에 set을 만들지는 않습니다.
rect.center = (190, 100)
print(rect.x)
print(rect.y)

3)Property Observer : Key Value Observing 이벤트 핸들링
=>프로퍼티의 값이 변경되는 것을 감시하는 기능
=>swift에서는 willSet 과 didSet을 이용하고 다른 언어에서는 setter 메소드를 직접 작성해서 만듭니다.
=>willSet은 프로퍼티의 값이 변경되기 전에 수행되는 내용 이 때는 newValue라는 프로퍼티가 전달되는데 이 프로퍼티는 변경될 값입니다.
=>didSet은 프로퍼티의 값이 변경된 후에 수행되는 내용 이 때는 oldValue 라는 프로퍼티가 전달되는데 이 값이 이전에 저장되어 있던 값

var 프로퍼티이름:자료형{
	willSet{
			내용
	}
	didSet{
		내용
	}
} 
=>iOS에서는 어떤 상태 변화가 일어나기 직전을 will 이라고 표현하고 상태 변화가 일어난 후를 did로 표현

public void setScore(int score){
	=>willSet - newValue : score
	this.score = score;
	=>didSet - oldValue : 변경되기 전의 score
}


=>이 개념을 잘 이용하면 MediaPlayer를 효율적으로 만들 수 있습니다.
여러 개의 음악을 재생한다던가 영상을 재생할 때 하나의 미디어 재생이 끝나고 난 후 다음 미디어 재생 준비를 하게되면 다음 미디어를 재생할 때 일정한 대기 시간이 필요합니다.
하나의 미디어가 재생 중에 있을 때 재생 시간이 90% 정도가 되면 이 때 다음 미디어의 재생 준비를 합니다.
미디어가 끊김 없이 재생되는 효과를 만들 수 있습니다.

4)클로저를 이용한 프로퍼티 초기화
=>프로퍼티는 생성자를 제외한 곳에서는 메소드를 호출해서 초기화 할 수 없습니다.
=>클로저를 이용하면 가능 : 인스턴스를 만들 때 1번만 호출됩니다.
let/var 프로퍼티이름:자료형 = {
	수행할 내용
	return 데이터
}()
=>인스턴스를 만들 때 어떤 작업을 수행하기 위해서 이 문법을 사용

5)static property
=>앞에 static을 붙이면 클래스가 사용할 수 있는 프로퍼티
=>인스턴스 없이 사용이 가능한 프로퍼티
=>인스턴스는 호출할 수 없고 클래스 이름으로만 호출해야 합니다.
=>만드는 목적은 모든 인스턴스가 공유하기 위해서 - 동일한 클래스로부터 만들어진 인스턴스 사이의 통신이 목적
=>static이라는 예약어 대신에 class라는 예약어로도 만들 수 있는데 class를 붙이면 연산 프로퍼티에만 적용해야 하고 상속한 경우 재정의가 가능

class Person{
    //프로퍼티를 이용한 초기화
    //이 초기화는 인스턴스를 생성할 때 1번만 호출
    var name:String = {
        print("프로퍼티의 초기화 : 클로저 이용")
        return "척준경"
    }()
    //클래스가 사용가능한 변수
    static var share:Int = 10
    //class 가 붙으면 연산 프로퍼티만 가능
    class var op : Int{
        get{
            return share + 100
        }
    }
}

//인스턴스 생성
var person1 : Person = Person()
var person2 : Person = Person()

//Java를 제외한 언어들은 인스턴스가 static 멤버를 호출 못함
//Java에서는 경고
//person1.share = 20 //에러

print(Person.share)
print(Person.op)

4.Method
=>self(this, me)
인스턴스가 메소드를 호출할 때 숨겨진 매개변수
인스턴스가 메소드를 호출하면 첫번째 매개변수로 인스턴스 자신의 참조를 같이 전달합니다.
인스턴스 메소드 안에서는 이 참조를 self 라는 이름으로 넘겨받습니다.
self.프로퍼티이름 이나 메소드이름 을 사용하게 되면 메소드 내부에서 프로퍼티나 메소드 이름을 찾지 않고 메소드 외부에서 부터 찾기 시작합니다.

1)Instance Method
=>인스턴스가 호출할 수 있는 메소드
=>static 프로퍼티와 instance 프로퍼티 모두 사용 가능

2)Static Method
=>클래스가 호출하는 메소드
=>static 프로퍼티만 사용
=>self가 없기 때문에 인스턴스가 소유하고 있는 프로퍼티에는 접근을 할 수 없습니다.

3)selector
=>Objective-C에서 함수나 메소드를 대입받기 위한 표현
=>매개변수가 없을 때는 함수나 메소드이름만 사용하면 되고 매개변수가 있는 경우는 메소드이름(매개변수이름:, 매개변수이름:…)의 형태로 대입

4)self를 반드시 사용해야 하는 경우
=>지역변수와 인스턴스변수의 이름이 같을 때 인스턴스 변수를 사용하고자 하면 반드시 self.을 붙여서 호출
