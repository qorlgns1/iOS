
**문자 관련 자료형

1.문자열: 0개 이상의 문자의 모임 - String

=>문자를 순서대로 저장하고 마지막에 null을 저장

=>한 줄의 문자열 상수는 “ ”안에 작성하고 여러 줄 문자열 상수를 만들고자 할 때는 “”” 문자열 “””

=>문자열 템플릿(보간): 문자열 안에 다른 변수의 데이터를 문자열로 삽입

“문자열 상수 \(변수 및 상수) ..”

변수나 상수가 저장하고 있는 내용을 문자열로 치환해서 삽입

다른 언어에서는 String 클래스의 format 이라는 메소드가 이 역할을 수행

=>String 클래스에 한해서는 아직도 Objective-C의 클래스인 NSString을 조금 더 많이 활용


2.문자: 1개의 문자 - Character

=>Swift에서는 변수를 만들 때 자료형을 Character로 명시하면 문자

var 또는 let 변수명 = “A” //String

var 또는 let 변수명:Character = “A” //Character


3.제어문자(Escape Sequence)

=>거의 모든 프로그래밍언어에서 사용하는 것으로 \다음에 하나의 문자를 추가해서 의미를 부여한 것

\0: null - nil(자료구조)

\n: line feed(줄 바꿈)

\r: garage return(커서를 맨 앞으로 보내는 것)

=>GUI Programming에서 줄바꿈을 하기 위해서 \n을 입력했는데 줄바꿈이 안되면 \r\n으로 입력


\t: 탭


\\, \’, \”, \:, \’

=>정규식(문자열 패턴을 나타내기 위한 식 - 정규식을 이용한 유효성 검사)을 입력할 때 \를 포함하고자 하면 \\\\ 해야 합니다.

콤마나 공백의 경우도 언어에 따라서는 반드시 \와 함께 해야 하는 경우가 있습니다.


\u{16진수 2자리}, \u{16진수 4자리}, \u{16진수 8자리}

=>16진수 1개는 4비트 : 한글이나 특수문자를 바이트 코드로 직접 입력할 때 사용

직접입력해야 하는 경우는 인코딩 때문


4.문자열 변수와 상수 그리고 문자 상수를 만들어서 출력


import UIKit

//var는 변수를 만들 때 사용
//자료형 추론으로 변수를 생성
//자료형을 명시하지 않음
var str = "Hello, playground"

//자료형 명시를 이용해서 String 생성
var msg:String = "Swift"

//Chracter는 반드시 자료형을 명시
var ch:Character = "T"

//값을 변경할 수 없는 상수를 생성
let temp = "HI"

//var로 만든 것은 변경이 가능하지만
//let으로 만든 것은 변경이 불가능
str = "Hi Playground"
//temp = "Hello"

//상수 와 변수 구분
//변수는 2개 이상의 스레드에서 동시에 사용하는 것이 위험하지만 상수는 상관없음

//콘솔에 출력 - iOS에서는 NSLog 가 더 효율적
print(str)
debugPrint(msg)
내용을 입력하세요.

**형 변환 과 자료형 검사

=>스위프트는 서로 다른 타입의 변수나 상수끼리의 연산을 허용하지 않음

정수형이더라도 Int 와 Int32 는 연산이 되지 않습니다.


1. 정수, 실수, Bool, String, Character 사이의 형 변환

변환하고자하는 자료형(데이터) 로 형변환

생성자를 호출해서 데이터의 자료형을 변환


var n1:Int = 32
var n2:Int32 = 27

//n1 + n2 는 에러 - swift는 자료형에 엄격해서 동일한 데이터 형태라도 자료형이 다르면 안됨
//n1 + Int(n2) 의 형태로 연산 - 한쪽 데이터를 다른쪽으로 변환을 해주어야 합니다.
내용을 입력하세요.
2. 그 이외 자료형의 형 변환 : as 연산자 사용

=>상속받은 관계 인 경우 형 변환 가능 - 상위 클래스 자료형으로 만든 것을 하위 클래스 자료형으로 변환할 때 주로 사용


UIView view = UIButton();

view.멤버 -> UIView의 멤버만 호출할 수 있음

(view as Button).멤버 -> UIButton 의 멤버를 호출할 수 있음

오버라이딩 된 멤버를 호출할 때는 형 변환을 안해도 됩니다.


=>Optional(nil을 저장할 수 있는 자료형 - 원래 자료형을 wrapping)을 원래 자료형으로 되돌릴 때도 사용


=>Swift의 자료형을 Objective-C의 자료형으로 변환하거나 Objective-C의 자료형을 Swift의 자료형으로 변환하고자 할 때 도 사용


3.자료형 확인

데이터 is 자료형

=>데이터의 자료형과 뒤에 설정한 자료형이 같으면 true 그렇지 않으면 false

=>자료형으로 변환이 가능하면 true


4.소스를 작성할 때 nil 여부 확인과 자료형을 확인하는 작업은 중요

=>swift 나 Kotlin이 nil 여부 확인의 번거로움을 줄이기 위해서 Optional을 추가했지만 실제 개발에서는 아직도 nil 검사나 자료형을 확인한 후 작업하는 것을 권장합니다.


클라이언트 프로그램에서는 추천하지 않지만 서버 프로그래머들은 습관적으로 nil 검사 수행하는 코드 와 자료형 검사하는 코드 그리고 예외처리 코드를 작성합니다.



5.숫자 데이터의 형 변환


var x : Int = 43
var y : Int32 = 27
//print(x + y) //2개의 자료형이 다르면 Swift는 연산할 수 없음
print(x + Int(y))
//y를 Int로 변경하던가 x를 Int32로 변경해서 연산
내용을 입력하세요.
6.API가 제공하는 데이터는 우리가 만드는 자료형과는 다를 수 있기 때문에 원하는 자료형으로 변환해서 사용할 수 있어야 합니다.


**Operator(연산자)

=>연산을 수행할 수 있도록 해주는 부호나 명령어

=>산술연산과 논리연산으로 분류

산술연산은 숫자 데이터를 가지고 수행하는 연산

논리연산은 boolean 데이터를 가지고 수행하는 연산

=>swift는 연산자 좌우에 공백이 일치해야 합니다.

왼쪽에 공백이 있으면 오른쪽에 공백이 있어야 하고 왼쪽에 공백이 없으면 오른쪽에도 공백이 없어야 합니다.


1.기본 할당(assignment) 연산자

=

=>오른쪽의 데이터를 왼쪽의 변수에 대입해주는 연산자

=>왼쪽에는 변수만 와야 하고 오른쪽은 표현식(값, 변수, 상수, 연산식, 메소드 호출 구문 등)이 오면 됩니다.


2.산술 연산자

=>%, *, /, +, -

=>% 는 정수 데이터에만 사용

=>실수의 나머지 연산은 truncatingRemainder라는 메소드를 이용

=>&+, &-, &* 은 오버플로우를 허용하는 연산

1)Overflow

=>크기가 정해진 데이터의 모임에서 크기를 벗어나는 데이터를 추가하고자 하는 경우 발생

정해진 Stack의 크기를 넘어서는 것을 StackOverflow 라고 합니다.

=>저장할 수 있는 숫자의 표현범위를 위쪽으로 넘어선 것으로 보통은 예외를 발생시키지만 상황에 따라서는 가장 작은 수에서부터 다시 시작하는 경우도 있음


2)Underflow

=>데이터의 모임에 데이터가 없는데 꺼낼 때

=>숫자의 표현범위를 아래쪽으로 넘어선 것


3.연산자 실습


//Int8 은 음수를 포함해서 저장
//-128 ~ + 127까지만 저장
var n1 : Int8 = 120
var n2 : Int8 = 8

//Overflow 발생
//var result : Int8 = n1 + n2
//print(result) //에러 발생

//Overflow가 발생하더라도 연산을 수행
var result : Int8 = n1 &+ n2
print(result) //결과 -128

//실수의 나머지를 바로 구할 수 없습니다.
//var mod = 1.7 % 1.5 //에러

//실수의 나머지 구하기
var mod = 1.7.truncatingRemainder(dividingBy: 1.5)
print(mod) //결과값 : 0.2 가 아닌 0.19999999999999996
내용을 입력하세요.

4.비교 연산자

>,>=,<,<=, ==, !=

=>동일한 자료형의 데이터를 가지고 비교해서 결과를 Bool로 리턴하는 연산자

=>상수는 자동으로 형변환을 수행하지만 변수는 반드시 자료형을 일치시켜서 수행

=>참조를 비교하는 ===, !== 연산자도 제공

동일한 데이터를 가지고 인스턴스를 생성해서 == 로 비교하면 true가 리턴되지만 ===로 비교하면 false가 리턴됨


5.불리언 논리 연산자

=>불리언 데이터를 가지고 연산을 해서 불리언으로 결과를 리턴하는 연산자

!(NOT), &&(AND), ||(OR)

=>!은 하나의 데이터를 받아서 결과를 반대로 리턴하는 연산자(true->false, false->true)

=>&&는 둘 다 true일 때만 true를 리턴하는 연산자, 첫번째 데이터의 결과가 false이면 뒤 데이터는 확인하지 않음

=>||는 둘 다 false일 때는 false를 리턴하는 연산자, 첫번째 데이터의 결과가 true이면 뒤 데이터는 확인하지 않음

=>! > && > ||


6.비트 논리 연산

=>정수 데이터를 이진수로 변환해서 연산을 수행하고 결과를 10진 정수 데이터로 리턴하는 연산자

-(2의 보수 연산자)

~(1의 보수 연산자): 0->1, 1->0 결과는 부호를 변경하고 절대값을 1더하거나 빼면 됩니다.

&(and)

|(or)

^(xor)


var n1:Int8 = 11  //0000 1011
var n2:Int8 = 12 //0000 1100
print(n1 & n2) //8
print(n1 | n2) //15
print(n1 ^ n2) //7
내용을 입력하세요.
7.shift 연산자

=>정수 데이터를 이진수로 변환해서 연산을 수행한 후 정수 데이터로 리턴

<< : 왼쪽으로 밀기 - 1번 밀 때 마다 2배씩 증가

>> : 오른쪽으로 밀기 - 1번 밀 때 마다 1/2로 감소


8.삼항 연산자

조건 ? true일 때 표현식 : false일 때 표현식


9.복합 할당 연산자

연산자=

=> += 은 왼쪽 변수의 데이터에 오른쪽의 값을 더해서 왼쪽의 변수에 대입


10.swift 3부터는 ++, -- 연산자가 없어졌음


11.nil 연산자

표현식1 ?? 표현식2

=>표현식1이 nil이면 표현식2를 수행

=>default를 만들어주는 기능

변수 = 표현식1 ?? 표현식2

표현식1이 nil 일 때 표현식2를 사용

=>센서의 값을 가져올 때 센서가 없다면 뒤의 표현식의 값을 대입


var n : Int?
print(n ?? 10) //n에 값이 없으므로 10
n = 7
print(n ?? 10) //n의 값이 있으므로 7
내용을 입력하세요.
12.범위 연산자

=>start . . . end : start 부터 end 까지의 순서열

=>start ..< end : start 부터 end 전까지

=>start를 생략하면 0

=>end를 생략할 수 있지만 순서열에서는 생략하지 않고 list에서 범위를 나타날 때 생략하면 맨 마지막 인덱스가 됩니다.

=>무조건 왼쪽에서 오른쪽으로 수행되기 때문에 왼쪽의 숫자가 작아야 합니다.

=>반대로 수행할 때는 reversed()를 호출


var range = 11...13 //11, 12, 13
for i in range{
    print(i)
} 

var list = ["제어문", "클래스"]
print(list[0...])
//["제어문", "클래스"]
내용을 입력하세요.
**Control Statement(제어문)

=>명령의 흐름을 변경할 수 있는 명령어

1.분류

1)분기

=>값에 의한 분기 : switch

=>조건에 의한 분기 : if


2)반복 - loop, iteration, cursor

=>iteration, cursor(데이터의 모임을 순서대로 순회) : for ~ in

=>loop : while, repeat ~ while


3)기타 제어문

=>break: 반복문을 중단

=>continue: 다음 반복으로 이동

=>return: 함수의 수행을 종료하고 함수를 호출한 곳으로 제어권을 이동


4)guard

=>if와 반대 형태로 동작하는 제어문인데 조건에 맞지 않으면 return

=>if는 조건에 맞지 않을 때 무엇인가를 수행하는 용도로 사용하지만 guard는 종료한다는 의미로 사용


2.if

1)단순 if

if 표현식{

표현식의 결과가 true일 때 수행할 내용

}

=>표현식의 괄호는 필요 없음

관습적으로 표현식의 괄호는 하는 것입니다.


2)if ~ else

if 표현식{

표현식의 결과가 true일 때 수행할 내용

}else{

표현식의 결과가 false일 때 수행할 내용

}


3)if ~ else if ~ else

=>else if는 개수에 제한 없음

=>else는 생략 가능

if 표현식{

표현식의 결과가 true일 때 수행할 내용

}else if 표현식{

위의 표현식이 거짓이고 이 표현식이 true일 때 수행할 내용

}else{

표현식의 결과가 false일 때 수행할 내용

}


3.switch

=>값에 의한 분기인데 범위 연산자 가능

=>case에 where를 추가할 수 있음

=>default가 필수

=>기본적으로 break가 없어도 fallthrough(아래 구문으로 내려가는 것)가 안됨

아래로 내려가고자 할 때 fallthrough를 입력해야 함

=>비교할 때 튜플(Tuple - 여러 개의 값의 모임) 사용이 가능


4.분기문 실습


//점수
var score = 77
//A, B, C, D, F 와 같은 학점 판별
//기본적으로 fallthrough 되지 않음
//default가 필수
//case에서 where를 이용해서 조건 설정 가능
switch score{
    case 90...100:
        print("A")
    case 80..<90:
        print("B")
    case 70..<80 where score % 2 == 0:
        print("B이면서 짝수")
    case 70..<80 where score % 2 == 1:
        print("B이면서 홀수")
    default:
        print("F")
}
내용을 입력하세요.

//튜플 생성
var data = ("배기훈", 80)
switch data{
    case(data.0, 0..<60):
    print("\(data.0)은 불합격입니다.")
default:
    print("\(data.0)은 합격입니다.")
}
//배기훈은 합격입니다.
내용을 입력하세요.
5.while

=>어떤 조건이 false가 될 때 까지 수행하도록 하고자 할 때 사용

=>반복해야 할 횟수는 알지 못하지만 조건은 알고 있을 때 사용

=>목적은 repeat ~ while과 동일하지만 의미상 repeat ~ while은 반드시 한 번은 한다라는 내용이 포함되어 있습니다.


while 표현식{

표현식이 false가 아닐 때 수행할 내용

}


6.repeat ~ while

=>while과 사용법은 유사

repeat{

표현식이 false가 아닐 때 수행할 내용

}while 표현식

=>반드시 1번은 수행해야 하는 경우를 이 표현법으로 작성하면 가독성이 높은 프로그램으로 간주


7.for ~ in

=>횟수를 알고있는 반복이나 데이터의 모임을 순서대로 사용하고자 할 때 사용 : for~each

=>Array, Dictionary, Set, String, 순서열 등에서 사용

for 임시변수 in 데이터의모임{

데이터의 모임을 순서대로 임시변수에 대입하고 수행할 내용

}

=>임시변수를 사용하지 않을 것 같으면 생략하는 것은 안되고 _ 라고 입력하면 됩니다.


//swift에서는 for의 용도가 이전의 for~each : 빠른 열거
var str : String = "Swift"

//문자열도 문자의 모임으로 간주 - for 사용 가능
for ch in str{
    print(ch)
}
//결과
S
w
i
f
t
내용을 입력하세요.
8.제어문은 중첩 가능

=>제어문 안에 제어문 사용이 가능


9.break

=>반복문 안에서 분기문과 같이 사용해서 반복문을 종료하는 명령어


10.continue

=>반복문 안에서 분기문과 같이 사용해서 다음 반복으로 넘어가는 명령어


11.반복문의 중첩

=>반복문 앞에 레이블을 추가하는 것이 가능

=>break 나 continue 할 때 레이블이름 같이 작성하면 레이블에 해당하는 반복문을 종료하거나 패스


for i in 1...10{
    if i % 3 == 0{
        break
    }
    print(i, terminator:" ")
}
print("\n=======================")
for i in 1...10{
    if i % 3 == 0{
        continue
    }
    print(i, terminator:" ")
}
//결과
1 2
=======================
1 2 4 5 7 8 10
내용을 입력하세요.

//OUTER 사용 
for I in 0 . . . 3{
   for j in 0 . . . 10{
//break. //j에 해당하는 반복문을 종료
break OUTER //OUTER의 반복문을 종료
  }
}
내용을 입력하세요.
12.guard

guard 표현식 else{

표현식이 false 일 때 수행할 내용

}

=>else가 필수


if !(표현식){

내용

}

와 구문 해석상 동일


=>if는 무엇인가 작업을 수행하지만 guard는 종료하는 역할을 수행하는 경우가 많음

=>대부분의 경우 { }안에 들어가는 문장은 return


func division(split:Int, divide:Int) -> Int{
    return split / divide
}
print(division(split: 10, divide: 3)) //결과값 : 3
print(division(split: 10, divide: 0)) //에러
내용을 입력하세요.

func guarddivision(split:Int, divide:Int) -> Int{
    //divide 가 0 이면 괄호안의 내용 수행
    guard divide != 0 else{
        print("0으로 나눌 수 없습니다.")
        return 0
    }
    return split / divide
}
print(guarddivision(split: 10, divide: 0)) //결과값 : 0
내용을 입력하세요.
**swift 운영체제 버전 확인

=>UIDevice.current.systemVersion 으로 운영체제 버전을 가져올 수 있음

플랫폼종류.버전 의 형태의 문자열로 리턴됩니다.

이 방법을 사용하는 경우에는 버전에 해당하는 숫자가 존재하는지 확인해서 사용

11버전 이상 을 확인할려면 11, 12, 13 있는지 확인


=>제어문을 이용해서 확인할 수 있는 방법을 제공

if #availavle(플랫폼종류 버전, *){

버전 이상일 때만 동작

}

//11버전 이상일 때

if #availavle(iOS 11.0, *){

버전 이상일 때만 동작

}

=>스마트 폰은 API가 자주 변경이 되기 때문에 코드를 작성하다보면 운영체제 버전에 따라 다른 API를 사용하는 경우가 많기 때문에 위 구문은 중요


//운영체제 버전 확인
print("운영체제 버전:", UIDevice.current.systemVersion) //결과 : 운영체제 버전: 13.6
//운영체제 버전이 12 이상일 때 와 그렇지 않을 때 작업
if #available(OSX 12.0, *){
    print("운영체제가 12.0 이상 일 때 수행할 구문")
}else{
    print("운영체제가 12.0 미만 일 때  수행할 구문")
}
내용을 입력하세요.
**Optional

=>Optional은 자료형이름이 아니고 일반 자료형을 nil을 저장할 수 있도록 래핑할 때 사용하는 이름

=>swift의 자료형들은 기본적으로 nil을 저장할 수 없습니다.

이러한 swift의 자료형에 nil을 저장할 수 있도록 만드는 것을 Optional Wrapping 이라고 합니다.

그리고 반대로 Optional Wrapping 된 데이터를 swift의 자료형으로 변경하는 것을 Optional Unwrapping 이라고 합니다.

=>Optional Wrapping을 하고자 할 때는 자료형 이름 뒤에 ?를 붙이면 됩니다.

Optional Wrapping 된 데이터는 다른 데이터와 연산을 할 수 없습니다.

Optional Wrapping 된 변수에만 nil을 저장할 수 있습니다.


//var str = nil // 이 구문은 에러
//swift에서는 일반 자료형 변수에 nil을 대입할 수 없습니다.

var str : String? //Optional로 선언해서 nil 대입 가능
str = nil

var n : Int?
n = 30
print(n) // 출력의 결과가 30은 아니지만 에러는 아님
//Optional 데이터는 다른 데이터와 연산을 할 수 없습니다.
//print(n + 20)
내용을 입력하세요.

//강제해제를 해서 연산을 수행
print(n! + 20)

n = nil
//nil은 강제로 해제가 되지 않기 때문에 확인하고 해제
if n != nil{
    print(n! + 20)
}
내용을 입력하세요.
1.옵셔널 해제

=>명시적 해제

강제 해제와 비강제 해제


=>묵시적 해제

컴파일러에 의해서 해제 되는 것이 있고 변수를 선언할 때 ? 대신에 !를 이용해서 해제


2.강제 해제

옵셔널 데이터 뒤에 !를 추가해서 강제로 옵셔널을 해제하는 것

여기에 대한 책임은 개발자가 집니다.

잘못될 가능성이 있기 때문에 개발자가 확인하고 사용해야 한다는 것입니다.

권장하는 형태는 nil 인지 확인하고 nil이 아니면 그 경우에만 강제 해제하도록 합니다.


3.비강제 해제

=>apple이 제공하는 샘플 코드에서 많이 등장

=>if 나 guard 구문에서 변수나 상수를 생성하고 값을 대입하면 값이 nil이면 false를 리턴하고 그렇지 않으면 true를 리턴


if var 또는 let 이름 = 데이터{

//데이터가 nil이 아닐 때 수행하는 구문

}else{

//데이터가 nil일 때 수행하는 구문

}

=>nil 일 가능성이 있는 메소드 호출을 할 때 많이 이용


4.컴파일러에 의한 자동 해제

=>Optional 타입에 ==, != 를 이용해서 비교하면 자동해제되서 비교가 됩니다.


5.묵시적 해제

=>Optional 변수를 선언할 때 ? 대신에 !를 사용하면 변수를 사용할 때 자동으로 !가 해제됩니다.

=>iOS Framework에서 인터페이스 빌더(IB - 스토리보드)에서 디자인 한 뷰를 뷰 컨트롤러 클래스에 드래그해서 변수를 생성하면 !를 붙여서 생성하기 때문에 Optional을 해제하지 않고 사용이 가능합니다.

=>이 경우도 일종의 강제 해제기 때문에 nil 인지 확인하고 사용하는 것을 권장

=>인터페이스 빌더에서 디자인 한 뷰를 연결한 변수는 반드시 생성했다는 보장이 있기 때문에 확인하지 않고 사용 - IBOutlet 이라는 단어가 앞에 붙어 있습니다.


//비강제 해제 예제

var x : Int?
//x가 nil 이기 때문에 다른 변수에 할당하면 false
//변수 생성 구문이 성공하면 이 변수는 if 외부에서도 사용 가능
//apple 의 샘플코드는 특별한 경우가 아니면
//nil을 확인하는 구문을 사용하지 않고 아래처럼 사용
if var y = x{
    print("성공")
}else{
    print("실패")
}                  //결과 실패

x = 100
if var k = x{
    print("성공")
}else{
    print("실패")
}                  //결과 성공

//컴파일러에 의한 해제 : == 나 != 연산자 사용 시
var z : Int = 70
if z == 70{
    print("일치")
}else{
    print("불일치")
}

//사용할 때 강제 해제 - 비추천
var temp : Int! = 30
//특별한 경우가 아니면 Optional은 var 로 선언
//Optional을 사용하는 이유 중 하나가
//nil을 대입해서 메모리 해제를 하기 위해서 입니다.
내용을 입력하세요.
**특수 자료형 : Swift의 자료형이 아니고 Objective-C의 자료형

=>Objective-C 의 자료형 이름은 NS가 앞에 붙습니다.

Swift:String , Objective-C :NSString

Objective-C는 Mutable 과 없는 것으로 구분

NSString(수정 불가능), NSMutableString(수정 가능)


=>Any: C언어의 void * - 모든 자료형의 데이터를 저장할 수 있는 자료형

저장을 할 때는 어떤 종류의 데이터이건 저장할 수 있지만 사용할 때는 반드시 강제 형 변환을 해서 사용을 합니다.


//Any 사용 예제
var any : Any = 123
//모든 자료형의 데이터를 저장할 수 있는 변수 선언
print(any) //출력

//사용은 반드시 형 변환을 해야 합니다.
print((any as! Int) + 234)
내용을 입력하세요.
=>AnyObject: Java 의 Object - 모든 인스턴스의 참조를 저장할 수 있는 자료형

저장을 할 때는 어떤 종류의 인스턴스이건 저장할 수 있지만 사용할 때는 반드시 강제 형 변환을 해서 사용을 합니다.


=>Selector: swift에서는 함수가 일급 객체(함수도 하나의 자료형)

함수 단위로 대입하는 것이 가능하지만 Objective-C는 함수가 일급 객체가 아니라서 함수를 아무곳에나 대입할 수 없어서 C언어의 함수 포인터처럼 사용할 수 있는 개념을 도입

#selector(함수 나 메소드) 형태로 생성


=>자바는 완전한 객체 지향 언어(모든 존재하는 것들은 전부 객체 안에 또는 클래스 안에 존재)

대입의 단위도 무조건 객체 또는 클래스만 가능

모든 클래스는 Object 클래스로부터 상속을 받아야 합니다.

swing 이나 Java F/X 또는 안드로이드에서 이벤트 핸들링을 할 때 실제로 보면 이벤트가 발생하면 호출되는 것은 함수입니다.

자바에서는 함수라는 개념이 존재하지 않아서 클래스를 만들어서 함수를 메소드로 선언하고 다시 객체(Listener)를 만들어서 대입합니다.

사용할 것은 메소드 1개 임에도 불구하고 다른 메소드를 같이 대입해야 합니다.



﻿
